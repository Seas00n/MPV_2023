/*
 * uart_communication.c
 *
 *  Created on: Feb 22, 2023
 *      Author: yuxuan
 */

#include "main.h"
#include "uart_communication.h"
#include "msg.h"
#include "debug_uart.h"
#include "stdio.h"
#include "stdarg.h"



static uint8_t txDataBuffer[40];
static uint8_t rxDataBuffer[40];
static uint32_t rx_len;
static uint32_t tx_len;


static uint8_t count = 0;

extern UART_HandleTypeDef huart6;


volatile P2M p2m_pc = {0x01,0x00,0x0000,0x0000,0x0000,0x0000,0x00,0xFF};//
volatile M2P m2p_pc = {0x01,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xFF};//

void Start_PCReceiveIT(){
	HAL_UARTEx_ReceiveToIdle_DMA(&huart6, rxDataBuffer, sizeof(rxDataBuffer));
}


void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size){
	if(huart==&huart6){
		rx_len = Size;
		PC_UnpackMessage();
		if(txDataBuffer[0]==0xFC&&txDataBuffer[sizeof(m2p_pc)-1]==0xFF){
			tx_len = sizeof(m2p_pc);
			HAL_UART_Transmit_DMA(&huart6, txDataBuffer,tx_len);
			count = 0;
			while(huart6.gState!=HAL_UART_STATE_READY){
				if(count>10){
					PC_CommunicationErrorHandler();
					break;
				}else{
					HAL_Delay(10);
					count+=1;
				}
			}
			HAL_UARTEx_ReceiveToIdle_DMA(&huart6, rxDataBuffer, sizeof(rxDataBuffer));
		}else{}
	}
}
// [0]0x(id)* ,[9]0x*F
void PC_UnpackMessage(){
	if(rx_len==10 && (rxDataBuffer[9]&0xf)==0xf){
		p2m_pc.head = 0x01;
		p2m_pc.id = (uint8_t)(rxDataBuffer[0]>>4&0xf);
		p2m_pc.value1 = (int16_t)(rxDataBuffer[1]<<8|rxDataBuffer[2]);
		p2m_pc.value2 = (int16_t)(rxDataBuffer[3]<<8|rxDataBuffer[4]);
		p2m_pc.value3 = (int16_t)(rxDataBuffer[5]<<8|rxDataBuffer[6]);
		p2m_pc.value4 = (int16_t)(rxDataBuffer[7]<<8|rxDataBuffer[8]);
		p2m_pc.ext_value = (uint8_t)((rxDataBuffer[0]&0xf<<4)|(rxDataBuffer[9]>>4&0xf));
		p2m_pc.head = 0xFC;
	}else{}
}

void PC_PackMessage(){
	if(m2p_pc.head==0xFC && m2p_pc.end==0xFF){
		m2pmsg_memcpy(txDataBuffer, m2p_pc);
	}
}
void PC_CommunicationErrorHandler(){
	debugPrint("Send to PC Failed\r\n");
}
